[{"content":"Nếu như trong lập trình web có mô hình MVC, thì trong lập trình ô tô (Automotive), chúng ta có AUTOSAR.\nKhi mới bắt đầu tìm hiểu về Automotive, mình đã bị \u0026ldquo;ngợp\u0026rdquo; bởi hàng trăm trang tài liệu về chuẩn này. Hôm nay, mình sẽ tóm tắt lại những ý cốt lõi nhất về AUTOSAR (Classic Platform) để các bạn có cái nhìn tổng quan trước khi đi sâu vào chi tiết.\n1. Tại sao lại cần AUTOSAR? Hãy tưởng tượng một chiếc xe hơi hiện đại có tới hơn 100 hộp ECU (Electronic Control Unit).\nECU động cơ do Bosch làm. ECU phanh ABS do Continental làm. ECU điều hòa do Denso làm. Nếu không có một chuẩn chung, việc tích hợp các thiết bị này lại với nhau sẽ là một cơn ác mộng. Code viết cho chip của hãng này sẽ không chạy được trên chip của hãng kia.\nAUTOSAR (AUTomotive Open System ARchitecture) ra đời để giải quyết vấn đề đó với phương châm:\n\u0026ldquo;Cooperate on standards, compete on implementation.\u0026rdquo; (Hợp tác trên các tiêu chuẩn, cạnh tranh trên việc thực thi.)\n2. Kiến trúc phân tầng (Layered Architecture) Điểm đặc biệt nhất của AUTOSAR là nó chia phần mềm thành các lớp rõ ràng. Điều này giúp tách biệt phần cứng (Hardware) và phần mềm ứng dụng (Application).\nMột cách dễ hiểu, nó giống như chiếc bánh Hamburger 3 lớp:\n2.1. Application Layer (Lớp ứng dụng - \u0026ldquo;Bánh mì trên\u0026rdquo;) Đây là nơi chứa logic điều khiển của xe (ví dụ: thuật toán điều khiển phun xăng, thuật toán bật đèn tự động\u0026hellip;). Các khối phần mềm ở đây được gọi là SWC (Software Component). Điều thú vị là các SWC này hoàn toàn không biết gì về phần cứng bên dưới.\n2.2. RTE (Runtime Environment - \u0026ldquo;Lớp phô mai/rau\u0026rdquo;) Đây là lớp trung gian, đóng vai trò như một \u0026ldquo;tổng đài điện thoại\u0026rdquo;.\nNếu SWC muốn gửi dữ liệu đi đâu, nó phải gọi qua RTE. RTE sẽ quyết định xem dữ liệu đó cần gửi cho một SWC khác nằm cùng chip, hay gửi ra ngoài qua mạng CAN/LIN. 2.3. Basic Software (BSW - \u0026ldquo;Lớp thịt/Bánh mì dưới\u0026rdquo;) Đây là phần gần phần cứng nhất, bao gồm:\nServices Layer: Hệ điều hành (OS), quản lý bộ nhớ, quản lý mạng. ECU Abstraction Layer: Trừu tượng hóa các chân I/O. MCAL (Microcontroller Abstraction Layer): Đây là lớp quan trọng nhất với anh em lập trình nhúng. Nó chứa các driver điều khiển trực tiếp thanh ghi (Register) của vi điều khiển (như GPIO, ADC, PWM\u0026hellip;). 3. Sự khác biệt trong cách Code Trong lập trình nhúng truyền thống (ví dụ trên STM32 dùng HAL Library), để đọc một nút nhấn, ta viết:\n1 2 3 4 5 6 // Lập trình truyền thống void Read_Button() { if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) { // Xử lý... } } ","permalink":"http://localhost:1313/notes/autosar/","summary":"Giải mã kiến trúc AUTOSAR (Classic Platform), tại sao nó lại quan trọng và cách nó thay đổi tư duy lập trình nhúng truyền thống.","title":"Tổng quan về AUTOSAR - Tiêu chuẩn 'vàng' của ngành Automotive"},{"content":"Chào mừng các bạn đến với dự án đầu tiên trên blog Tai no Biboroku.\nLà một sinh viên Cơ điện tử, việc tự tay chế tạo một chú Mobile Robot (Robot di động) luôn là một cột mốc đáng nhớ. Trong bài viết này, mình sẽ chia sẻ lại quá trình xây dựng một Mobile Robot cơ bản sử dụng dòng chip STM32, tập trung vào việc xử lý cân bằng tốc độ động cơ bằng giải thuật PID.\n1. Tại sao lại chọn STM32? Ban đầu mình định dùng Arduino Uno vì sự đơn giản. Tuy nhiên, với mục tiêu học sâu về Embedded Systems và chuẩn bị cho các dự án Automotive sau này, mình quyết định chọn STM32F103C8T6 (Blue Pill).\nLý do rất đơn giản:\nTốc độ xử lý: 72MHz (so với 16MHz của Arduino). Nhiều ngoại vi: Nhiều kênh PWM, ADC tốc độ cao và đặc biệt là Hardware Timer hỗ trợ tốt cho Encoder. Môi trường: Làm quen với KeilC và thư viện HAL là bước đệm tốt cho công việc kỹ sư nhúng. 2. Phần cứng (Hardware Design) Để robot hoạt động ổn định, mình đã lựa chọn các linh kiện sau:\nVi điều khiển: STM32F103C8T6. Động cơ: 2 Motor DC giảm tốc GA25-370 (có gắn sẵn Encoder để đo tốc độ). Driver điều khiển động cơ: Module TB6612FNG (nhỏ gọn và hiệu suất cao hơn L298N). Cảm biến: HC-SR04 (đo khoảng cách vật cản) và MPU6050 (đo góc nghiêng/gia tốc). Nguồn: Pin Li-ion 18650 2S (7.4V). Sơ đồ nguyên lý được thiết kế trên Altium Designer, sau đó mình tự ủi mạch và hàn linh kiện để tối ưu kích thước.\n3. Giải thuật điều khiển (PID Control) Thách thức lớn nhất của các robot 2 bánh là làm sao để nó đi thẳng. Do sai số cơ khí, hai động cơ dù cấp cùng một điện áp nhưng tốc độ thực tế sẽ khác nhau, dẫn đến robot bị lệch hướng.\nGiải pháp ở đây là Bộ điều khiển PID.\nInput: Tốc độ thực tế đọc từ Encoder. Setpoint: Tốc độ mong muốn. Output: Xung PWM cấp cho Driver. Dưới đây là đoạn code C mình triển khai PID trên STM32:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* Cấu trúc dữ liệu PID */ typedef struct { float Kp, Ki, Kd; float error, pre_error; float integral; float output; } PID_Config; /* Hàm tính toán PID - Gọi trong ngắt Timer mỗi 10ms */ float PID_Calculate(PID_Config *pid, float setpoint, float current_speed) { // 1. Tính sai số pid-\u0026gt;error = setpoint - current_speed; // 2. Tính thành phần P, I, D float P_term = pid-\u0026gt;Kp * pid-\u0026gt;error; pid-\u0026gt;integral += pid-\u0026gt;error; float I_term = pid-\u0026gt;Ki * pid-\u0026gt;integral; float D_term = pid-\u0026gt;Kd * (pid-\u0026gt;error - pid-\u0026gt;pre_error); // 3. Tính ngõ ra pid-\u0026gt;output = P_term + I_term + D_term; // 4. Lưu sai số cho lần tính sau pid-\u0026gt;pre_error = pid-\u0026gt;error; // Giới hạn xung PWM (Clamping) if (pid-\u0026gt;output \u0026gt; 1000) pid-\u0026gt;output = 1000; if (pid-\u0026gt;output \u0026lt; 0) pid-\u0026gt;output = 0; return pid-\u0026gt;output; } ","permalink":"http://localhost:1313/projects/robot/","summary":"Quá trình thiết kế và lập trình Mobile Robot tự hành sử dụng vi điều khiển STM32F103, giải thuật PID","title":"Mobile Robot Project"},{"content":"Xin chào! Đây là bài viết đầu tiên trên blog kỹ thuật của tôi.\nMục tiêu của tôi: Xây dựng blog bằng Hugo Chia sẻ về dự án xe tự hành Viết về STM32 và Embedded System Dưới đây là một đoạn code C mẫu (để test giao diện):\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, Embedded World!\u0026#34;); return 0; } ","permalink":"http://localhost:1313/posts/hello-world/","summary":"\u003ch2 id=\"xin-chào\"\u003eXin chào!\u003c/h2\u003e\n\u003cp\u003eĐây là bài viết đầu tiên trên blog kỹ thuật của tôi.\u003c/p\u003e\n\u003ch3 id=\"mục-tiêu-của-tôi\"\u003eMục tiêu của tôi:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e Xây dựng blog bằng Hugo\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Chia sẻ về dự án xe tự hành\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Viết về STM32 và Embedded System\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDưới đây là một đoạn code C mẫu (để test giao diện):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Hello, Embedded World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"First Post"}]